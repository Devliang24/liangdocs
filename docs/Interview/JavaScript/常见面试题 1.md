## var、let、const 区别

### let相对于 var

1. 不存在变量提升
2. 存在暂时性死区：作用域内被声明，不受外部影响
3. 不允许重复声明
4. 有块级作用域：外层代码块不受内层代码块的影响

### const 相对于 let

1. 声明必须初始化

2. 只读常量，变量的值不能修改

   - 简单类型 ：值就保存在变量指向的那个内存地址，等同于常量。

   - 引用类型：变量指向的内存地址，保存的只是一个指向实际数据的指针；

      const 只能保证指针固定，不能控制指向的数据结构。

   

## Generator

一是，`function`关键字与函数名之间有一个星号；

二是，函数体内部使用`yield`表达式，定义不同的内部状态。

```js
function* helloWorldGenerator() {
  let a = yield 'hello';
  console.log(a) //123
  let b = yield 'world';
  console.log(b) //undefined
  return 'ending';
}

var hw = helloWorldGenerator();
hw.next()
hw.next(123) //a = 123
```

`nex()`传参会赋值给上一次`yield`的的返回值

### 异步流程同步化

```js
function* test(){
  let res1 = yield new Promise((resolve) =>{
    setTimeout(function(){
      resolve('第一秒执行')
    },1000)
  })
  console.log(res1) //第一秒执行
  
   let res2 = yield new Promise((resolve) =>{
    setTimeout(function(){
      resolve('第二秒执行')
    },1000)
  })
}

function generatorRunner(fn){
	let generator = fn()
  let step = generator.next()
  //定义递归函数
  function loop(stepArg,generator){
    //获取本次 yield 右侧的结果
    let value = stepArg.value
    if(value instanceof Promise){
      //如果是 Promise 对象就在 then 函数的回调中获取本次程序结果
      //并且等待回调执行的时候进入下一次递归
      value.then((function(promiseValue){
        if(!stepArg.done){
          loop(generator.next(promiseValue),generator)
        }
      }
    }else{
          //判断程序没有执行完就将本次结果传入下一步进入下一次递归
  		if(!stepArg.done) loop(generator.next(stepArg.value),generator)
 	}
  }
  loop(step,generator)
}
```





















