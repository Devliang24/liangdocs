## var、let、const 区别

### let相对于 var

1. 不存在变量提升
2. 存在暂时性死区：作用域内被声明，不受外部影响
3. 不允许重复声明
4. 有块级作用域：外层代码块不受内层代码块的影响

### const 相对于 let

1. 声明必须初始化

2. 只读常量，变量的值不能修改

   - 简单类型 ：值就保存在变量指向的那个内存地址，等同于常量。

   - 引用类型：变量指向的内存地址，保存的只是一个指向实际数据的指针；

      const 只能保证指针固定，不能控制指向的数据结构。


## 防抖与节流

防抖：频繁触发某个事件时，在设定的时间内再次触发，会重新清除上一次定时器，重新开启定时器开始计时。

节流：频繁触发某个事件时，保证设定的时间内只会执行一次，只有等执行完才会打开节流阀执行下一个事件。

### 防抖

```js
//实现原理：每次触发事件时，取消之前的定时器，重新计时
function dobunce(func,delay){
  let timer = null
  return function(...args){
    if(timer) clearTimeout(timer) //清除上一次
    timer = setTimeout(() =>{
      func.apply(this,args)
    },delay)
  }
}
```



### 节流

```js
//实现原理：每次触发事件时，判断当前是否存在等待执行的延时函数
function throttle(func,delay){
  let flag = true //节流阀：开启状态
  return function(...args){
    if(!flag) return 
    flag = false //已经在处理：关闭
    setTimeout(() =>{
      func.apply(this,args)
      flag = true //处理完：重新打开
    },delay)
  }
  }
}
//实现二：当前时间-上次执行时间 > 设定时间，才执行
funtion throttle(func,delay){
  let start = 0
  return function(...args){
    let now = Data.now()
    if(now - start > delay){
       func.apply(this,args)
   		 start = now
    }
  }
}
```



::: tip 应用

​	防抖：输入框搜索、编辑框实时保存，（手机息屏策略，王者荣耀回程操作）

​	节流：滚动到底部加载更多、图标跟随鼠标（地铁发车时间，王者荣耀技能冷却）

:::



## Generator

一是，`function`关键字与函数名之间有一个星号；

二是，函数体内部使用`yield`表达式，定义不同的内部状态。

```js
function* helloWorldGenerator() {
  let a = yield 'hello';
  console.log(a) //123
  let b = yield 'world';
  console.log(b) //undefined
  return 'ending';
}

var hw = helloWorldGenerator();
hw.next()
hw.next(123) //a = 123
```

`nex()`传参会赋值给上一次`yield`的的返回值

### 异步流程同步化

```js
function* test(){
  let res1 = yield new Promise((resolve) =>{
    setTimeout(function(){
      resolve('第一秒执行')
    },1000)
  })
  console.log(res1) //第一秒执行
  
   let res2 = yield new Promise((resolve) =>{
    setTimeout(function(){
      resolve('第二秒执行')
    },1000)
  })
}

function generatorRunner(fn){
	let generator = fn()
  let step = generator.next()
  //定义递归函数
  function loop(stepArg,generator){
    //获取本次 yield 右侧的结果
    let value = stepArg.value
    if(value instanceof Promise){
      //如果是 Promise 对象就在 then 函数的回调中获取本次程序结果
      //并且等待回调执行的时候进入下一次递归
      value.then((function(promiseValue){
        if(!stepArg.done){
          loop(generator.next(promiseValue),generator)
        }
      }
    }else{
          //判断程序没有执行完就将本次结果传入下一步进入下一次递归
  		if(!stepArg.done) loop(generator.next(stepArg.value),generator)
 	}
  }
  loop(step,generator)
}
```





















